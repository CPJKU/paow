#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
In this experiment we play keys generated by approximate limit points of the logistic map.
Over the course of the 40 minutes the r parameter of the logistic map ascends from 3.49 to 3.86, 
crossing several regions of chaotic and oscillatory behavior.

Enjoy!
"""
from mido import Message, MidiFile, MidiTrack
import numpy as np
import matplotlib.pyplot as plt
import os
os.environ['KMP_DUPLICATE_LIB_OK']='True'

notes_per_tempo = 15
# tempos: 1000 tempos
# MIDI default parts per quarter is 480, MIDI default tempo is 120 bpm -> 960 ticks/sec
tempos_in_notes_per_sec = np.linspace(5,8,1000)
tempos_in_ticks_per_note = 960 / tempos_in_notes_per_sec

total_duration_in_hours = (1/tempos_in_notes_per_sec * notes_per_tempo).sum()/3600 
# get nice integer times divisible by two
tempos_in_ticks_per_note_int = np.round(tempos_in_ticks_per_note / 2).astype(int) 

mid = MidiFile()
track = MidiTrack()
mid.tracks.append(track)

def lmap(x, r = 1):
    return r * x * (1 - x)

# pitches = np.arange(21,21+88)
pitches = list()
scale = np.array([0,1,4,5,7,8,11])
for octave in range(7):
    for p in scale:
        pitches.append(octave*12 + p + 21 + 1)

pitches = np.array(pitches)
rs = np.linspace(3.49, 3.86, notes_per_tempo * 1000)
xs = list()
# creating the notes
for l in range(1000):
    # lowest MIDI pitch: 21
    order = np.random.permutation(np.arange(21,21+88))
    local_duration_halfed = tempos_in_ticks_per_note_int[l] 
    for k in range(notes_per_tempo): 

        x = np.random.rand()
        for n in range(1000): 
            x = lmap(x, rs[notes_per_tempo*l + k])
        xs.append(x)
        pitch = pitches[np.clip(int(x*len(pitches)),0,len(pitches)-1)]
        track.append(Message('note_on', note=pitch, velocity=np.random.randint(20,30), time=local_duration_halfed))
        track.append(Message('note_off', note=pitch, velocity=0, time=local_duration_halfed))


mid.save('logistic_midi_map.mid')
plt.scatter(rs, xs, s = 0.1)
plt.show()


